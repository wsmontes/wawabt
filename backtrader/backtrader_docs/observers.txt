Skip to content
logo
Backtrader
Observers - Statistics
 DRo
 backtrader
19.3k
4.7k
Search
 
Home
Documentation
Articles
Recipes/Resources
Documentation
Introduction
Installation
Quickstart Guide
Concepts
Cerebro
Data Feeds
Strategy
Indicators
Orders
Broker
Commission Schemes
Analyzers
Observers
Observers - Statistics
Observers - Benchmarking
Observers - Reference
Sizers
Live Trading
Plotting
Datetime
Automated Running
Table of contents
Accesing the Observers
Observer Implementation
Adding Observers to the Strategy
Developing Observers
Custom OrderObserver
Saving/Keeping the statistics
Observers and Statistics
Strategies running inside the backtrader do mostly deal with data feeds and indicators.

Data feeds are added to Cerebro instances and end up being part of the input of strategies (parsed and served as attributes of the instance) whereas Indicators are declared and managed by the Strategy itself.

All backtrader sample charts have so far had 3 things plotted which seem to be taken for granted because they are not declared anywhere:

Cash and Value (what’s happening with the money in the broker)

Trades (aka Operations)

Buy/Sell Orders

They are Observers and exist within the submodule backtrader.observers. They are there because Cerebro supports a parameter to automatically add (or not) them to the Strategy:

stdstats (default: True)
If the default is respected Cerebro executes the following equivalent user code:


import backtrader as bt

...

cerebro = bt.Cerebro()  # default kwarg: stdstats=True

cerebro.addobserver(bt.observers.Broker)
cerebro.addobserver(bt.observers.Trades)
cerebro.addobserver(bt.observers.BuySell)
Let’s see the usual chart with those 3 default observers (even if no order is issued and therefore no trade happens and there is no change to the cash and portfolio value)


from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import backtrader as bt
import backtrader.feeds as btfeeds

if __name__ == '__main__':
    cerebro = bt.Cerebro(stdstats=False)
    cerebro.addstrategy(bt.Strategy)

    data = bt.feeds.BacktraderCSVData(dataname='../../datas/2006-day-001.txt')
    cerebro.adddata(data)

    cerebro.run()
    cerebro.plot()
image

Now let’s change the value of stdstats to False when creating the Cerebro instance (can also be done when invoking run):


cerebro = bt.Cerebro(stdstats=False)
The chart is different now.

image

Accesing the Observers
The Observers as seen above are already there in the default case and collecting information which can be used for statistical purposes and that’s why acess to the observers can be done through an attribute of the strategy called:

stats
It is simply a placeholder. If we recall the addition of one of the default Observers as laid out above:


...
cerebro.addobserver(backtrader.observers.Broker)
...
The obvious question would be how to access the Broker observer. Here for example how it’s done from the next method of a strategy:


class MyStrategy(bt.Strategy):

    def next(self):

        if self.stats.broker.value[0] < 1000.0:
           print('WHITE FLAG ... I LOST TOO MUCH')
        elif self.stats.broker.value[0] > 10000000.0:
           print('TIME FOR THE VIRGIN ISLANDS ....!!!')
The Broker observer just like a Data, an Indicator and the Strategy itself is also a Lines objects. In this case the Broker has 2 lines:

cash

value

Observer Implementation
The implementation is very similar to that of an Indicator:


class Broker(Observer):
    alias = ('CashValue',)
    lines = ('cash', 'value')

    plotinfo = dict(plot=True, subplot=True)

    def next(self):
        self.lines.cash[0] = self._owner.broker.getcash()
        self.lines.value[0] = value = self._owner.broker.getvalue()
Steps:

Derive from Observer (and not from Indicator)

Declare lines and params as needed (Broker has 2 lines but no params)

There will be an automatic attribute _owner which is the strategy holding the observer

Observers come in action:

After all Indicators have been calculated

After the Strategy next method has been executed

That means: at the end of the cycle … they observe what has happened

In the Broker case it’s simply blindly recording the broker cash and portfolio values at each point in time.

Adding Observers to the Strategy
As already pointed out above, Cerebro is using the stdstats parameter to decide whether to add 3 default Observers, alleviating the work of the end user.

Adding other Observers to the mix is possible, be it along the stdstats or removing those.

Let’s go for the usual strategy which buys when the close price goes above a SimpleMovingAverage and sells if the opposite is true.

With one “addition”:

DrawDown which is an already existing observer in the backtrader ecosystem

from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import argparse
import datetime
import os.path
import time
import sys


import backtrader as bt
import backtrader.feeds as btfeeds
import backtrader.indicators as btind


class MyStrategy(bt.Strategy):
    params = (('smaperiod', 15),)

    def log(self, txt, dt=None):
        ''' Logging function fot this strategy'''
        dt = dt or self.data.datetime[0]
        if isinstance(dt, float):
            dt = bt.num2date(dt)
        print('%s, %s' % (dt.isoformat(), txt))

    def __init__(self):
        # SimpleMovingAverage on main data
        # Equivalent to -> sma = btind.SMA(self.data, period=self.p.smaperiod)
        sma = btind.SMA(period=self.p.smaperiod)

        # CrossOver (1: up, -1: down) close / sma
        self.buysell = btind.CrossOver(self.data.close, sma, plot=True)

        # Sentinel to None: new ordersa allowed
        self.order = None

    def next(self):
        # Access -1, because drawdown[0] will be calculated after "next"
        self.log('DrawDown: %.2f' % self.stats.drawdown.drawdown[-1])
        self.log('MaxDrawDown: %.2f' % self.stats.drawdown.maxdrawdown[-1])

        # Check if we are in the market
        if self.position:
            if self.buysell < 0:
                self.log('SELL CREATE, %.2f' % self.data.close[0])
                self.sell()

        elif self.buysell > 0:
            self.log('BUY CREATE, %.2f' % self.data.close[0])
            self.buy()


def runstrat():
    cerebro = bt.Cerebro()

    data = bt.feeds.BacktraderCSVData(dataname='../../datas/2006-day-001.txt')
    cerebro.adddata(data)

    cerebro.addobserver(bt.observers.DrawDown)

    cerebro.addstrategy(MyStrategy)
    cerebro.run()

    cerebro.plot()


if __name__ == '__main__':
    runstrat()
The visual output shows the evolution of the drawdown

image

And part of the text output:


...
2006-12-14T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-15T23:59:59+00:00, DrawDown: 0.22
2006-12-15T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-18T23:59:59+00:00, DrawDown: 0.00
2006-12-18T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-19T23:59:59+00:00, DrawDown: 0.00
2006-12-19T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-20T23:59:59+00:00, DrawDown: 0.10
2006-12-20T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-21T23:59:59+00:00, DrawDown: 0.39
2006-12-21T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-22T23:59:59+00:00, DrawDown: 0.21
2006-12-22T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-27T23:59:59+00:00, DrawDown: 0.28
2006-12-27T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-28T23:59:59+00:00, DrawDown: 0.65
2006-12-28T23:59:59+00:00, MaxDrawDown: 2.62
2006-12-29T23:59:59+00:00, DrawDown: 0.06
2006-12-29T23:59:59+00:00, MaxDrawDown: 2.62
Note

As seen in the text output and in the code, the DrawDown observer has actually 2 lines:

drawdown

maxdrawdown

The choice is not to plot the maxdrawdown line, but make it is still available to the user.

Actually the last value of maxdrawdown is also available in a direct attribute (not a line) with the name of maxdd

Developing Observers
The implementation of the Broker observer was shown above. To produce a meaningful observer, the implementation can use the following information:

self._owner is the currently strategy being executed

As such anything within the strategy is available to the observer

Default internal things available in the strategy which may be useful:

broker -> attribute giving access to the broker instance the strategy creates order against
As seen in Broker, cash and portfolio values are collected by invoking the methods getcash and getvalue

_orderspending -> list orders created by the strategy and for which the broker has notified an event to the strategy.
The BuySell observer traverses the list looking for orders which have executed (totally or partially) to create an average execution price for the given point in time (index 0)

_tradespending -> list of trades (a set of completed buy/sell or sell/buy pairs) which is compiled from the buy/sell orders
An Observer can obviously access other observers over the self._owner.stats path.

Custom OrderObserver
The standard BuySell observer does only care about operations which have executed. We can create an observer which shows when orders where created and if they expired.

For the sake of visibility the display will not be plotted along the price but on a separate axis.


from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import math

import backtrader as bt


class OrderObserver(bt.observer.Observer):
    lines = ('created', 'expired',)

    plotinfo = dict(plot=True, subplot=True, plotlinelabels=True)

    plotlines = dict(
        created=dict(marker='*', markersize=8.0, color='lime', fillstyle='full'),
        expired=dict(marker='s', markersize=8.0, color='red', fillstyle='full')
    )

    def next(self):
        for order in self._owner._orderspending:
            if order.data is not self.data:
                continue

            if not order.isbuy():
                continue

            # Only interested in "buy" orders, because the sell orders
            # in the strategy are Market orders and will be immediately
            # executed

            if order.status in [bt.Order.Accepted, bt.Order.Submitted]:
                self.lines.created[0] = order.created.price

            elif order.status in [bt.Order.Expired]:
                self.lines.expired[0] = order.created.price
The custom observer only cares about buy orders, because this is a strategy which only buys to try to make a profit. Sell orders are Market orders and will be executed immediately.

The Close-SMA CrossOver strategy is changed to:

Create a Limit order with a price below 1.0% the close price at the moment of the signal

A validity for the order of 7 (calendar) days

The resulting chart.

image

Several orders have expired as can be seen in the new subchart (red squares) and we can also appreciate that between “creation” and “execution” several days happen to be.

Finally the code for this strategy which applies the new observer


from __future__ import (absolute_import, division, print_function,
                        unicode_literals)

import datetime

import backtrader as bt
import backtrader.feeds as btfeeds
import backtrader.indicators as btind

from orderobserver import OrderObserver


class MyStrategy(bt.Strategy):
    params = (
        ('smaperiod', 15),
        ('limitperc', 1.0),
        ('valid', 7),
    )

    def log(self, txt, dt=None):
        ''' Logging function fot this strategy'''
        dt = dt or self.data.datetime[0]
        if isinstance(dt, float):
            dt = bt.num2date(dt)
        print('%s, %s' % (dt.isoformat(), txt))

    def notify_order(self, order):
        if order.status in [order.Submitted, order.Accepted]:
            # Buy/Sell order submitted/accepted to/by broker - Nothing to do
            self.log('ORDER ACCEPTED/SUBMITTED', dt=order.created.dt)
            self.order = order
            return

        if order.status in [order.Expired]:
            self.log('BUY EXPIRED')

        elif order.status in [order.Completed]:
            if order.isbuy():
                self.log(
                    'BUY EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                    (order.executed.price,
                     order.executed.value,
                     order.executed.comm))

            else:  # Sell
                self.log('SELL EXECUTED, Price: %.2f, Cost: %.2f, Comm %.2f' %
                         (order.executed.price,
                          order.executed.value,
                          order.executed.comm))

        # Sentinel to None: new orders allowed
        self.order = None

    def __init__(self):
        # SimpleMovingAverage on main data
        # Equivalent to -> sma = btind.SMA(self.data, period=self.p.smaperiod)
        sma = btind.SMA(period=self.p.smaperiod)

        # CrossOver (1: up, -1: down) close / sma
        self.buysell = btind.CrossOver(self.data.close, sma, plot=True)

        # Sentinel to None: new ordersa allowed
        self.order = None

    def next(self):
        if self.order:
            # pending order ... do nothing
            return

        # Check if we are in the market
        if self.position:
            if self.buysell < 0:
                self.log('SELL CREATE, %.2f' % self.data.close[0])
                self.sell()

        elif self.buysell > 0:
            plimit = self.data.close[0] * (1.0 - self.p.limitperc / 100.0)
            valid = self.data.datetime.date(0) + \
                datetime.timedelta(days=self.p.valid)
            self.log('BUY CREATE, %.2f' % plimit)
            self.buy(exectype=bt.Order.Limit, price=plimit, valid=valid)


def runstrat():
    cerebro = bt.Cerebro()

    data = bt.feeds.BacktraderCSVData(dataname='../../datas/2006-day-001.txt')
    cerebro.adddata(data)

    cerebro.addobserver(OrderObserver)

    cerebro.addstrategy(MyStrategy)
    cerebro.run()

    cerebro.plot()


if __name__ == '__main__':
    runstrat()
Saving/Keeping the statistics
As of now backtrader has not implemented any mechanism to track the values of observers storing them into files. The best way to do it:

Open a file in the start method of the strategy

Write the values down in the next method of the strategy

Considering the DrawDown observer, it could be done like this


class MyStrategy(bt.Strategy):

    def start(self):

        self.mystats = open('mystats.csv', 'wb')
        self.mystats.write('datetime,drawdown, maxdrawdown\n')

    def next(self):
        self.mystats.write(self.data.datetime.date(0).strftime('%Y-%m-%d'))
        self.mystats.write(',%.2f' % self.stats.drawdown.drawdown[-1])
        self.mystats.write(',%.2f' % self.stats.drawdown.maxdrawdown-1])
        self.mystats.write('\n')
To save the values of index 0, once all observers have been processed a custom observer which writes to a file could be added as the last observer to the system to save values to a csv file.

Note

The Writer functionality can automate this task.

(C) 2015-2024 Daniel Rodriguez


Skip to content
logo
Backtrader
Observers - Benchmarking
 DRo
 backtrader
19.3k
4.7k
Search
 
Home
Documentation
Articles
Recipes/Resources
Documentation
Introduction
Installation
Quickstart Guide
Concepts
Cerebro
Data Feeds
Strategy
Indicators
Orders
Broker
Commission Schemes
Analyzers
Observers
Observers - Statistics
Observers - Benchmarking
Observers - Reference
Sizers
Live Trading
Plotting
Datetime
Automated Running
Table of contents
Analyzers - Benchmarking
Observers - Benchmarking
Observing TimeReturn
Observing Benchmarking
Observing Benchmarking - Another data
Concluding
The code
Benchmarking
Ticket #89 is about adding benchmarking against an asset. Sensible as one may actually have a strategy that even if positive is below what simply tracking the asset would have delivered.

backtrader includes 2 different types of objects which can aid with tracking:

Observers

Analyzers

In the realm of Analyzers there was already a TimeReturn object which tracks the evolution of the returns of the entire portfolio value (i.e: including cash)

This could have also obviously been an Observer, so whilst adding some benchmarking some work has also gone into being able to plug together an Observer and an Analyzer which are meant to track the same thing.

Note

The major difference between Observers and Analyzers is the lines nature of observers, which record every value and this makes them suitable

s for plotting and real time querying. This of course consumes memory.

Analyzers on the other hand return a set of results via get_analysis and the implementation may not deliver any result until the very end of a run.

Analyzers - Benchmarking
The standard TimeReturn analyzer has been extended to support tracking a data feed. The 2 major parameters invoved:

timeframe (default: None) If None then the complete return over the entire backtested period will be reported

Pass TimeFrame.NoTimeFrame to consider the entire dataset with no time constraints

data (default: None)

Reference asset to track instead of the portfolio value.

Note

this data must have been added to a cerebro instance with addata, resampledata or replaydata

For more details and parameters: Analyzers Reference

As such, the returns of the porftolio on a yearly basis can be tracked like this


import backtrader as bt

cerebro = bt.Cerebro()
cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years)

...  # add datas, strategies ...

results = cerebro.run()
strat0 = results[0]

# If no name has been specified, the name is the class name lowercased
tret_analyzer = strat0.analyzers.getbyname('timereturn')
print(tret_analyzer.get_analysis())
If we wanted to track the returns of a data


import backtrader as bt

cerebro = bt.Cerebro()

data = bt.feeds.OneOfTheFeeds(dataname='abcde', ...)
cerebro.adddata(data)

cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years,
                    data=data)

...  # add strategies ...

results = cerebro.run()
strat0 = results[0]

# If no name has been specified, the name is the class name lowercased
tret_analyzer = strat0.analyzers.getbyname('timereturn')
print(tret_analyzer.get_analysis())
If both are to be tracked, the best is to assign names to the analyzers


import backtrader as bt

cerebro = bt.Cerebro()

data = bt.feeds.OneOfTheFeeds(dataname='abcde', ...)
cerebro.adddata(data)

cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years,
                    data=data, _name='datareturns')

cerebro.addanalyzer(bt.analyzers.TimeReturn, timeframe=bt.TimeFrame.Years)
                    _name='timereturns')

...  # add strategies ...

results = cerebro.run()
strat0 = results[0]

# If no name has been specified, the name is the class name lowercased
tret_analyzer = strat0.analyzers.getbyname('timereturns')
print(tret_analyzer.get_analysis())
tdata_analyzer = strat0.analyzers.getbyname('datareturns')
print(tdata_analyzer.get_analysis())
Observers - Benchmarking
Thanks to the background machinery allowing the usage of Analyzers inside Observers, 2 new observers have been added:

TimeReturn

Benchmark

Both use the bt.analyzers.TimeReturn analyzer to collect results.

Rather than having code snippets like above, a full sample with some runs to show their functionality.

Observing TimeReturn
Execution:


$ ./observer-benchmark.py --plot --timereturn --timeframe notimeframe
image

Notice the execution options:

--timereturn telling the sample to do just that

--timeframe notimeframe telling the analyzer to consider the entire data set disregarding timeframe boundaries.

The last plotted value is -0.26.

The starting cash (obvious from the chart) are 50K monetary units and the strategy ends up with 36,970 monetary units and hence a -26% value decrement.
Observing Benchmarking
Because benchmarking will also display the timereturn results, let’s run the same thing but with benchmarking active:


$ ./observer-benchmark.py --plot --timeframe notimeframe
image

Hey, hey hey!!!

The strategy is better than the asset: -0.26 vs -0.33

It shouldn’t be a matter for celebration but at least is clear the strategy is not even as bad as the asset.

Moving down to track things on a yearly basis:


$ ./observer-benchmark.py --plot --timeframe years
image

Watch out!

The strategy last value has changed very slightly from -0.26 to -0.27

The asset on the on the other hand shows a last value of -0.35 (versus -0.33 above)

The reason for values so close to each other is that when moving from 2005 to 2006, both the strategy and the benchmarking asset were almost at the starting level from the beginning of 2005.

Switching to a lower timeframe like weeks, the entire picture changes:


$ ./observer-benchmark.py --plot --timeframe weeks

.. image:: 04-benchmarking-weeks.png
Now:

The Benchmark observer shows a much more nervous aspect. Things move up and down, because now weekly returns for both the portfolio and the data are being tracked

And because no trade was active in the last week of the year and the asset barely moved, the last displayed values are 0.00 (The last closing value before the last week was 25.54 and the sample data closed at 25.55, and the difference is felt first at the 4th decimal point)

Observing Benchmarking - Another data
The sample allows to benchmark against a different data. The default is to benchmark against Oracle when using --benchdata1. Considering the entire dataset with --timeframe notimeframe:


$ ./observer-benchmark.py --plot --timeframe notimeframe --benchdata1
image

It’s clear now why there was no reason for celebration above:

The results of the strategy have not changed for notimeframe and remain at -26% (-0.26)

But when benchmarking against another data, this data has a +23% (0.23 ) in the same period

Either the strategy needs a change or another asset better be traded.

Concluding
There are now two ways, using the same underlying code/calculations, to track the TimeReturn and Benchmark

Observers (TimeReturn and Benchmark)
and

Analyzer (TimeReturn and TimeReturn with a data parameter)
Of course benchmarking doesn’t guarantee profit, just comparison.

Usage of the sample:


$ ./observer-benchmark.py --help
usage: observer-benchmark.py [-h] [--data0 DATA0] [--data1 DATA1]
                             [--benchdata1] [--fromdate FROMDATE]
                             [--todate TODATE] [--printout] [--cash CASH]
                             [--period PERIOD] [--stake STAKE] [--timereturn]
                             [--timeframe {months,days,notimeframe,years,None,weeks}]
                             [--plot [kwargs]]

Benchmark/TimeReturn Observers Sample

optional arguments:
  -h, --help            show this help message and exit
  --data0 DATA0         Data0 to be read in (default:
                        ../../datas/yhoo-1996-2015.txt)
  --data1 DATA1         Data1 to be read in (default:
                        ../../datas/orcl-1995-2014.txt)
  --benchdata1          Benchmark against data1 (default: False)
  --fromdate FROMDATE   Starting date in YYYY-MM-DD format (default:
                        2005-01-01)
  --todate TODATE       Ending date in YYYY-MM-DD format (default: 2006-12-31)
  --printout            Print data lines (default: False)
  --cash CASH           Cash to start with (default: 50000)
  --period PERIOD       Period for the crossover moving average (default: 30)
  --stake STAKE         Stake to apply for the buy operations (default: 1000)
  --timereturn          Use TimeReturn observer instead of Benchmark (default:
                        None)
  --timeframe {months,days,notimeframe,years,None,weeks}
                        TimeFrame to apply to the Observer (default: None)
  --plot [kwargs], -p [kwargs]
                        Plot the read data applying any kwargs passed For
                        example: --plot style="candle" (to plot candles)
                        (default: None)
The code

from __future__ import (absolute_import, division, print_function,
                        unicode_literals)


import argparse
import datetime
import random

import backtrader as bt


class St(bt.Strategy):
    params = (
        ('period', 10),
        ('printout', False),
        ('stake', 1000),
    )

    def __init__(self):
        sma = bt.indicators.SMA(self.data, period=self.p.period)
        self.crossover = bt.indicators.CrossOver(self.data, sma)

    def start(self):
        if self.p.printout:
            txtfields = list()
            txtfields.append('Len')
            txtfields.append('Datetime')
            txtfields.append('Open')
            txtfields.append('High')
            txtfields.append('Low')
            txtfields.append('Close')
            txtfields.append('Volume')
            txtfields.append('OpenInterest')
            print(','.join(txtfields))

    def next(self):
        if self.p.printout:
            # Print only 1st data ... is just a check that things are running
            txtfields = list()
            txtfields.append('%04d' % len(self))
            txtfields.append(self.data.datetime.datetime(0).isoformat())
            txtfields.append('%.2f' % self.data0.open[0])
            txtfields.append('%.2f' % self.data0.high[0])
            txtfields.append('%.2f' % self.data0.low[0])
            txtfields.append('%.2f' % self.data0.close[0])
            txtfields.append('%.2f' % self.data0.volume[0])
            txtfields.append('%.2f' % self.data0.openinterest[0])
            print(','.join(txtfields))

        if self.position:
            if self.crossover < 0.0:
                if self.p.printout:
                    print('CLOSE {} @%{}'.format(size,
                                                 self.data.close[0]))
                self.close()

        else:
            if self.crossover > 0.0:
                self.buy(size=self.p.stake)
                if self.p.printout:
                    print('BUY   {} @%{}'.format(self.p.stake,
                                                self.data.close[0]))


TIMEFRAMES = {
    None: None,
    'days': bt.TimeFrame.Days,
    'weeks': bt.TimeFrame.Weeks,
    'months': bt.TimeFrame.Months,
    'years': bt.TimeFrame.Years,
    'notimeframe': bt.TimeFrame.NoTimeFrame,
}


def runstrat(args=None):
    args = parse_args(args)

    cerebro = bt.Cerebro()
    cerebro.broker.set_cash(args.cash)

    dkwargs = dict()
    if args.fromdate:
        fromdate = datetime.datetime.strptime(args.fromdate, '%Y-%m-%d')
        dkwargs['fromdate'] = fromdate

    if args.todate:
        todate = datetime.datetime.strptime(args.todate, '%Y-%m-%d')
        dkwargs['todate'] = todate

    data0 = bt.feeds.YahooFinanceCSVData(dataname=args.data0, **dkwargs)
    cerebro.adddata(data0, name='Data0')

    cerebro.addstrategy(St,
                        period=args.period,
                        stake=args.stake,
                        printout=args.printout)

    if args.timereturn:
        cerebro.addobserver(bt.observers.TimeReturn,
                            timeframe=TIMEFRAMES[args.timeframe])
    else:
        benchdata = data0
        if args.benchdata1:
            data1 = bt.feeds.YahooFinanceCSVData(dataname=args.data1, **dkwargs)
            cerebro.adddata(data1, name='Data1')
            benchdata = data1

        cerebro.addobserver(bt.observers.Benchmark,
                            data=benchdata,
                            timeframe=TIMEFRAMES[args.timeframe])

    cerebro.run()

    if args.plot:
        pkwargs = dict()
        if args.plot is not True:  # evals to True but is not True
            pkwargs = eval('dict(' + args.plot + ')')  # args were passed

        cerebro.plot(**pkwargs)


def parse_args(pargs=None):

    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description='Benchmark/TimeReturn Observers Sample')

    parser.add_argument('--data0', required=False,
                        default='../../datas/yhoo-1996-2015.txt',
                        help='Data0 to be read in')

    parser.add_argument('--data1', required=False,
                        default='../../datas/orcl-1995-2014.txt',
                        help='Data1 to be read in')

    parser.add_argument('--benchdata1', required=False, action='store_true',
                        help=('Benchmark against data1'))

    parser.add_argument('--fromdate', required=False,
                        default='2005-01-01',
                        help='Starting date in YYYY-MM-DD format')

    parser.add_argument('--todate', required=False,
                        default='2006-12-31',
                        help='Ending date in YYYY-MM-DD format')

    parser.add_argument('--printout', required=False, action='store_true',
                        help=('Print data lines'))

    parser.add_argument('--cash', required=False, action='store',
                        type=float, default=50000,
                        help=('Cash to start with'))

    parser.add_argument('--period', required=False, action='store',
                        type=int, default=30,
                        help=('Period for the crossover moving average'))

    parser.add_argument('--stake', required=False, action='store',
                        type=int, default=1000,
                        help=('Stake to apply for the buy operations'))

    parser.add_argument('--timereturn', required=False, action='store_true',
                        default=None,
                        help=('Use TimeReturn observer instead of Benchmark'))

    parser.add_argument('--timeframe', required=False, action='store',
                        default=None, choices=TIMEFRAMES.keys(),
                        help=('TimeFrame to apply to the Observer'))

    # Plot options
    parser.add_argument('--plot', '-p', nargs='?', required=False,
                        metavar='kwargs', const=True,
                        help=('Plot the read data applying any kwargs passed\n'
                              '\n'
                              'For example:\n'
                              '\n'
                              '  --plot style="candle" (to plot candles)\n'))

    if pargs:
        return parser.parse_args(pargs)

    return parser.parse_args()


if __name__ == '__main__':
    runstrat()
(C) 2015-2024 Daniel Rodriguez


Skip to content
logo
Backtrader
Observers - Reference
 DRo
 backtrader
19.3k
4.7k
Search
 
Home
Documentation
Articles
Recipes/Resources
Documentation
Introduction
Installation
Quickstart Guide
Concepts
Cerebro
Data Feeds
Strategy
Indicators
Orders
Broker
Commission Schemes
Analyzers
Observers
Observers - Statistics
Observers - Benchmarking
Observers - Reference
Sizers
Live Trading
Plotting
Datetime
Automated Running
Table of contents
Benchmark
class backtrader.observers.Benchmark()
Broker
class backtrader.observers.Broker(*args, **kwargs)
Broker - Cash
class backtrader.observers.Cash(*args, **kwargs)
Broker - Value
class backtrader.observers.Value(*args, **kwargs)
BuySell
class backtrader.observers.BuySell(*args, **kwargs)
DrawDown
class backtrader.observers.DrawDown()
TimeReturn
class backtrader.observers.TimeReturn()
Trades
class backtrader.observers.Trades()
LogReturns
class backtrader.observers.LogReturns()
LogReturns2
class backtrader.observers.LogReturns2()
FundValue
class backtrader.observers.FundValue(*args, **kwargs)
FundShares
class backtrader.observers.FundShares(*args, **kwargs)
Observers Reference
Benchmark
class backtrader.observers.Benchmark()
This observer stores the returns of the strategy and the return of a reference asset which is one of the datas passed to the system.

Params:

timeframe (default: None) If None then the complete return over the entire backtested period will be reported

compression (default: None)

Only used for sub-day timeframes to for example work on an hourly timeframe by specifying “TimeFrame.Minutes” and 60 as compression

data (default: None)

Reference asset to track to allow for comparison.

NOTE: this data must have been added to a cerebro instance with addata, resampledata or replaydata.

_doprenext (default: False)

Benchmarking will take place from the point at which the strategy kicks in (i.e.: when the minimum period of the strategy has been met).

Setting this to True will record benchmarking values from the starting point of the data feeds

firstopen (default: False)

Keepint it as False ensures that the 1st comparison point between the value and the benchmark starts at 0%, because the benchmark will not use its opening price.

See the TimeReturn analyzer reference for a full explanation of the meaning of the parameter

fund (default: None)

If None the actual mode of the broker (fundmode - True/False) will be autodetected to decide if the returns are based on the total net asset value or on the fund value. See set_fundmode in the broker documentation

Set it to True or False for a specific behavior

Remember that at any moment of a run the current values can be checked by looking at the lines by name at index 0.

Broker
class backtrader.observers.Broker(*args, **kwargs)
This observer keeps track of the current cash amount and portfolio value in the broker (including the cash)

Params: None

Broker - Cash
class backtrader.observers.Cash(*args, **kwargs)
This observer keeps track of the current amount of cash in the broker

Params: None

Broker - Value
class backtrader.observers.Value(*args, **kwargs)
This observer keeps track of the current portfolio value in the broker including the cash

Params:

fund (default: None)

If None the actual mode of the broker (fundmode - True/False) will be autodetected to decide if the returns are based on the total net asset value or on the fund value. See set_fundmode in the broker documentation

Set it to True or False for a specific behavior

BuySell
class backtrader.observers.BuySell(*args, **kwargs)
This observer keeps track of the individual buy/sell orders (individual executions) and will plot them on the chart along the data around the execution price level

Params:


* `barplot` (default: `False`) Plot buy signals below the minimum and
  sell signals above the maximum.

  If `False` it will plot on the average price of executions during a
  bar

* `bardist` (default: `0.015` 1.5%) Distance to max/min when
  `barplot` is `True`
DrawDown
class backtrader.observers.DrawDown()
This observer keeps track of the current drawdown level (plotted) and the maxdrawdown (not plotted) levels

Params:

fund (default: None)

If None the actual mode of the broker (fundmode - True/False) will be autodetected to decide if the returns are based on the total net asset value or on the fund value. See set_fundmode in the broker documentation

Set it to True or False for a specific behavior

TimeReturn
class backtrader.observers.TimeReturn()
This observer stores the returns of the strategy.

Params:

timeframe (default: None) If None then the complete return over the entire backtested period will be reported

Pass TimeFrame.NoTimeFrame to consider the entire dataset with no time constraints

compression (default: None)

Only used for sub-day timeframes to for example work on an hourly timeframe by specifying “TimeFrame.Minutes” and 60 as compression

fund (default: None)

If None the actual mode of the broker (fundmode - True/False) will be autodetected to decide if the returns are based on the total net asset value or on the fund value. See set_fundmode in the broker documentation

Set it to True or False for a specific behavior

Remember that at any moment of a run the current values can be checked by looking at the lines by name at index 0.

Trades
class backtrader.observers.Trades()
This observer keeps track of full trades and plot the PnL level achieved when a trade is closed.

A trade is open when a position goes from 0 (or crossing over 0) to X and is then closed when it goes back to 0 (or crosses over 0 in the opposite direction)

Params:


* `pnlcomm` (def: `True`)

  Show net/profit and loss, i.e.: after commission. If set to `False`
  if will show the result of trades before commission
LogReturns
class backtrader.observers.LogReturns()
This observer stores the log returns of the strategy or a

Params:

timeframe (default: None) If None then the complete return over the entire backtested period will be reported

Pass TimeFrame.NoTimeFrame to consider the entire dataset with no time constraints

compression (default: None)

Only used for sub-day timeframes to for example work on an hourly timeframe by specifying “TimeFrame.Minutes” and 60 as compression

fund (default: None)

If None the actual mode of the broker (fundmode - True/False) will be autodetected to decide if the returns are based on the total net asset value or on the fund value. See set_fundmode in the broker documentation

Set it to True or False for a specific behavior

Remember that at any moment of a run the current values can be checked by looking at the lines by name at index 0.

LogReturns2
class backtrader.observers.LogReturns2()
Extends the observer LogReturns to show two instruments

FundValue
class backtrader.observers.FundValue(*args, **kwargs)
This observer keeps track of the current fund-like value

Params: None

FundShares
class backtrader.observers.FundShares(*args, **kwargs)
This observer keeps track of the current fund-like shares

Params: None

(C) 2015-2024 Daniel Rodriguez


